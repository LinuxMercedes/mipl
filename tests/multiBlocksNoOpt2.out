TOKEN: VAR     	LEXEME: var
TOKEN: IDENT     LEXEME: x
TOKEN: SEMICOL   LEXEME: ;
N -> epsilon

>>> Added x to symbol table
TOKEN: IDENT     LEXEME: y
TOKEN: SEMICOL   LEXEME: ;
N -> epsilon

>>> Added y to symbol table
TOKEN: IDENT     LEXEME: q
TOKEN: SEMICOL   LEXEME: ;
N -> epsilon

>>> Added q to symbol table
TOKEN: LCURLY    LEXEME: {
V -> epsilon
V -> id N ; V
V -> id N ; V
V -> id N ; V
TOKEN: IDENT     LEXEME: x
TOKEN: ASSIGN    LEXEME: =
TOKEN: INTCONST  LEXEME: 5
E -> INTCONST
TOKEN: SEMICOL   LEXEME: ;
A -> id = E

*** Found x in symbol table

x = 5  
S -> A ;
TOKEN: IDENT     LEXEME: y
TOKEN: ASSIGN    LEXEME: =
TOKEN: INTCONST  LEXEME: 7
E -> INTCONST
TOKEN: SEMICOL   LEXEME: ;
A -> id = E

*** Found y in symbol table

y = 7  
S -> A ;
TOKEN: WHILE     LEXEME: while
TOKEN: LPAREN    LEXEME: (
L1:
TOKEN: IDENT     LEXEME: x
TOKEN: GT		LEXEME: >
E -> id

*** Found x in symbol table

R -> >
TOKEN: IDENT     LEXEME: y
TOKEN: RPAREN    LEXEME: )
E -> id

*** Found y in symbol table

B -> E R E
t1 = x > y
if t1 == false goto L2
TOKEN: WHILE     LEXEME: while
TOKEN: LPAREN    LEXEME: (
L3:
TOKEN: IDENT     LEXEME: y
TOKEN: LT		LEXEME: <
E -> id

*** Found y in symbol table

R -> <
TOKEN: INTCONST  LEXEME: 100
E -> INTCONST
TOKEN: RPAREN    LEXEME: )
B -> E R E
t2 = y < 100
if t2 == false goto L4
TOKEN: IDENT     LEXEME: x
TOKEN: ASSIGN    LEXEME: =
TOKEN: IDENT     LEXEME: x
TOKEN: ADD       LEXEME: +
E -> id

*** Found x in symbol table

TOKEN: INTCONST  LEXEME: 10
E -> E + INTCONST
t3 = x + 10
TOKEN: SEMICOL   LEXEME: ;
A -> id = E

*** Found x in symbol table

x = t3  
S -> A ;
S -> while ( B ) S
goto L3
L4:
S -> W
S -> while ( B ) S
goto L1
L2:
S -> W
TOKEN: IDENT     LEXEME: q
TOKEN: ASSIGN    LEXEME: =
TOKEN: INTCONST  LEXEME: 4
E -> INTCONST
TOKEN: SEMICOL   LEXEME: ;
A -> id = E

*** Found q in symbol table

q = 4  
S -> A ;
TOKEN: RCURLY    LEXEME: }
C -> epsilon
C -> S ; C
C -> S ; C
C -> S ; C
C -> S ; C
P -> var V { C }

---- Completed parsing ----


List of instructions:
(0) x = 5  
(1) y = 7  
(2) L1:
(3) t1 = x > y
(4) if t1 == false goto L2
(5) L3:
(6) t2 = y < 100
(7) if t2 == false goto L4
(8) t3 = x + 10
(9) x = t3  
(10) goto L3
(11) L4:
(12) goto L1
(13) L2:
(14) q = 4  

Block leaders are as follows:
(0)
(2)
(5)
(8)
(11)
(13)


Blocks are as follows:
B0: (0) - (1)
B1: (2) - (4)
B2: (5) - (7)
B3: (8) - (10)
B4: (11) - (12)
B5: (13) - (14)

Executing constantFolding for (0) - (1)
Executing algebraicSimplification for (0) - (1)
Executing commonSubexprElimination for (0) - (1)
(0) x = 5  
(1) y = 7  
(2) L1:
(3) t1 = x > y
(4) if t1 == false goto L2
(5) L3:
(6) t2 = y < 100
(7) if t2 == false goto L4
(8) t3 = x + 10
(9) x = t3  
(10) goto L3
(11) L4:
(12) goto L1
(13) L2:
(14) q = 4  

Eliminating temp vars that have constant value
Executing constantFolding for (2) - (4)
Executing algebraicSimplification for (2) - (4)
Executing commonSubexprElimination for (2) - (4)
(0) x = 5  
(1) y = 7  
(2) L1:
(3) t1 = x > y
(4) if t1 == false goto L2
(5) L3:
(6) t2 = y < 100
(7) if t2 == false goto L4
(8) t3 = x + 10
(9) x = t3  
(10) goto L3
(11) L4:
(12) goto L1
(13) L2:
(14) q = 4  

Eliminating temp vars that have constant value
Executing constantFolding for (5) - (7)
Executing algebraicSimplification for (5) - (7)
Executing commonSubexprElimination for (5) - (7)
(0) x = 5  
(1) y = 7  
(2) L1:
(3) t1 = x > y
(4) if t1 == false goto L2
(5) L3:
(6) t2 = y < 100
(7) if t2 == false goto L4
(8) t3 = x + 10
(9) x = t3  
(10) goto L3
(11) L4:
(12) goto L1
(13) L2:
(14) q = 4  

Eliminating temp vars that have constant value
Executing constantFolding for (8) - (10)
Executing algebraicSimplification for (8) - (10)
Executing commonSubexprElimination for (8) - (10)
(0) x = 5  
(1) y = 7  
(2) L1:
(3) t1 = x > y
(4) if t1 == false goto L2
(5) L3:
(6) t2 = y < 100
(7) if t2 == false goto L4
(8) t3 = x + 10
(9) x = t3  
(10) goto L3
(11) L4:
(12) goto L1
(13) L2:
(14) q = 4  

Eliminating temp vars that have constant value
Executing constantFolding for (11) - (12)
Executing algebraicSimplification for (11) - (12)
Executing commonSubexprElimination for (11) - (12)
(0) x = 5  
(1) y = 7  
(2) L1:
(3) t1 = x > y
(4) if t1 == false goto L2
(5) L3:
(6) t2 = y < 100
(7) if t2 == false goto L4
(8) t3 = x + 10
(9) x = t3  
(10) goto L3
(11) L4:
(12) goto L1
(13) L2:
(14) q = 4  

Eliminating temp vars that have constant value
Executing constantFolding for (13) - (14)
Executing algebraicSimplification for (13) - (14)
Executing commonSubexprElimination for (13) - (14)
(0) x = 5  
(1) y = 7  
(2) L1:
(3) t1 = x > y
(4) if t1 == false goto L2
(5) L3:
(6) t2 = y < 100
(7) if t2 == false goto L4
(8) t3 = x + 10
(9) x = t3  
(10) goto L3
(11) L4:
(12) goto L1
(13) L2:
(14) q = 4  

Eliminating temp vars that have constant value

New list of optimized instructions:
(0) x = 5  
(1) y = 7  
(2) L1:
(3) t1 = x > y
(4) if t1 == false goto L2
(5) L3:
(6) t2 = y < 100
(7) if t2 == false goto L4
(8) t3 = x + 10
(9) x = t3  
(10) goto L3
(11) L4:
(12) goto L1
(13) L2:
(14) q = 4  
