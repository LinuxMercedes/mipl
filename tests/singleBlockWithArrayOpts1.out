TOKEN: VAR     	LEXEME: var
TOKEN: IDENT     LEXEME: A
TOKEN: LBRACK	LEXEME: [
TOKEN: INTCONST  LEXEME: 4
TOKEN: RBRACK	LEXEME: ]
TOKEN: SEMICOL   LEXEME: ;
N -> epsilon
N -> [ INTCONST ] N

>>> Added A to symbol table
>>> with the following subscriptInfo:
     s[0] = 4
TOKEN: IDENT     LEXEME: B
TOKEN: LBRACK	LEXEME: [
TOKEN: INTCONST  LEXEME: 5
TOKEN: RBRACK	LEXEME: ]
TOKEN: LBRACK	LEXEME: [
TOKEN: INTCONST  LEXEME: 4
TOKEN: RBRACK	LEXEME: ]
TOKEN: SEMICOL   LEXEME: ;
N -> epsilon
N -> [ INTCONST ] N
N -> [ INTCONST ] N

>>> Added B to symbol table
>>> with the following subscriptInfo:
     s[0] = 5
     s[1] = 4
TOKEN: LCURLY    LEXEME: {
V -> epsilon
V -> id N ; V
V -> id N ; V
TOKEN: IDENT     LEXEME: B
TOKEN: LBRACK	LEXEME: [
TOKEN: INTCONST  LEXEME: 1
E -> INTCONST
TOKEN: RBRACK	LEXEME: ]
L -> id [ E ]

*** Found B in symbol table
*** This array has the following subscriptInfo:
     s[0] = 5
     s[1] = 4

t1 = 1 * 4
TOKEN: LBRACK	LEXEME: [
TOKEN: IDENT     LEXEME: A
TOKEN: LBRACK	LEXEME: [
TOKEN: INTCONST  LEXEME: 2
E -> INTCONST
TOKEN: RBRACK	LEXEME: ]
L -> id [ E ]

*** Found A in symbol table
*** This array has the following subscriptInfo:
     s[0] = 4

t2 = 2 * 1
TOKEN: RBRACK	LEXEME: ]
E -> L
t3 = A[t2]
L -> L [ E ]

*** Found B in symbol table
*** This array has the following subscriptInfo:
     s[0] = 5
     s[1] = 4

t4 = t3 * 1
t5 = t1 + t4
TOKEN: ASSIGN    LEXEME: =
TOKEN: IDENT     LEXEME: A
TOKEN: LBRACK	LEXEME: [
TOKEN: INTCONST  LEXEME: 1
E -> INTCONST
TOKEN: RBRACK	LEXEME: ]
L -> id [ E ]

*** Found A in symbol table
*** This array has the following subscriptInfo:
     s[0] = 4

t6 = 1 * 1
TOKEN: SEMICOL   LEXEME: ;
E -> L
t7 = A[t6]
A -> L = E
B[t5] = t7
S -> A ;
TOKEN: RCURLY    LEXEME: }
C -> epsilon
C -> S ; C
P -> var V { C }

---- Completed parsing ----


List of instructions:
(0) t1 = 1 * 4
(1) t2 = 2 * 1
(2) t3 = A[t2]
(3) t4 = t3 * 1
(4) t5 = t1 + t4
(5) t6 = 1 * 1
(6) t7 = A[t6]
(7) B[t5] = t7

Block leaders are as follows:
(0)


Blocks are as follows:
B0: (0) - (7)

Executing constantFolding for (0) - (7)
Executing algebraicSimplification for (0) - (7)
Executing commonSubexprElimination for (0) - (7)
(0) t1 = 4  
(1) t2 = 2  
(2) t3 = A[t2]
(3) t4 = t3  
(4) t5 = t1 + t4
(5) t6 = 1  
(6) t7 = A[t6]
(7) B[t5] = t7
Executing constantFolding for (0) - (7)
Executing algebraicSimplification for (0) - (7)
Executing commonSubexprElimination for (0) - (7)
(0) t1 = 4  
(1) t2 = 2  
(2) t3 = A[2]
(3) t4 = t3  
(4) t5 = 4 + t4
(5) t6 = 1  
(6) t7 = A[1]
(7) B[t5] = t7
Executing constantFolding for (0) - (7)
Executing algebraicSimplification for (0) - (7)
Executing commonSubexprElimination for (0) - (7)
(0) t1 = 4  
(1) t2 = 2  
(2) t3 = A[2]
(3) t4 = t3  
(4) t5 = 4 + t4
(5) t6 = 1  
(6) t7 = A[1]
(7) B[t5] = t7

Eliminating temp vars that have constant value
(0) can be deleted
(1) can be deleted
(5) can be deleted

New list of optimized instructions:
(0) t3 = A[2]
(1) t4 = t3  
(2) t5 = 4 + t4
(3) t7 = A[1]
(4) B[t5] = t7
